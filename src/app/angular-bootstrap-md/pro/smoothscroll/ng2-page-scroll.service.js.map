{"version":3,"sources":["../../../../src/app/typescripts/pro/smoothscroll/ng2-page-scroll.service.ts"],"names":[],"mappings":"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","file":"ng2-page-scroll.service.js","sourceRoot":"","sourcesContent":["import {Injectable, isDevMode} from '@angular/core';\r\n\r\nimport {PageScrollConfig} from './ng2-page-scroll-config';\r\nimport {PageScrollInstance, InterruptReporter} from './ng2-page-scroll-instance';\r\nimport {PageScrollUtilService as Util} from './ng2-page-scroll-util.service';\r\n\r\n\r\nexport class PageScrollService {\r\n\r\n    private static instanceCounter = 0;\r\n\r\n    private runningInstances: PageScrollInstance[] = [];\r\n\r\n    private onInterrupted: InterruptReporter = {\r\n        report: (event: Event, pageScrollInstance: PageScrollInstance): void => {\r\n            if (!pageScrollInstance.interruptible) {\r\n                // Non-interruptible anyway, so do not stop anything\r\n                return;\r\n            }\r\n\r\n            let shouldStop = true;\r\n\r\n            if (event.type === 'keyup') {\r\n                // Only stop if specific keys have been pressed, for all others don't stop anything\r\n                if (PageScrollConfig._interruptKeys.indexOf((<KeyboardEvent>event).keyCode) === -1) {\r\n                    // The pressed key is not in the list of interrupting keys\r\n                    shouldStop = false;\r\n                }\r\n            } else if (event.type === 'mousedown') {\r\n                // For mousedown events we only stop the scroll animation of the mouse has\r\n                // been clicked inside the scrolling container\r\n                if (!pageScrollInstance.scrollingViews.some(scrollingView => scrollingView.contains(event.target))) {\r\n                    // Mouse clicked an element which is not inside any of the the scrolling containers\r\n                    shouldStop = false;\r\n                }\r\n            }\r\n\r\n            if (shouldStop) {\r\n                this.stopAll(pageScrollInstance.namespace);\r\n            }\r\n        }\r\n    };\r\n\r\n    private stopInternal(interrupted: boolean, pageScrollInstance: PageScrollInstance): boolean {\r\n        let index: number = this.runningInstances.indexOf(pageScrollInstance);\r\n        if (index >= 0) {\r\n            this.runningInstances.splice(index, 1);\r\n        }\r\n\r\n        if (pageScrollInstance.interruptListenersAttached) {\r\n            pageScrollInstance.detachInterruptListeners();\r\n        }\r\n\r\n        if (pageScrollInstance.timer) {\r\n            // Clear/Stop the timer\r\n            clearInterval(pageScrollInstance.timer);\r\n            // Clear the reference to this timer\r\n            pageScrollInstance.timer = undefined;\r\n            pageScrollInstance.fireEvent(!interrupted);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Start a scroll animation. All properties of the animation are stored in the given {@link PageScrollInstance} object.\r\n     *\r\n     * This is the core functionality of the whole library.\r\n     *\r\n     * @param pageScrollInstance\r\n     */\r\n    public start(pageScrollInstance: PageScrollInstance): void {\r\n        // Stop all possibly running scroll animations in the same namespace\r\n        this.stopAll(pageScrollInstance.namespace);\r\n\r\n        if (pageScrollInstance.scrollingViews === null || pageScrollInstance.scrollingViews.length === 0) {\r\n            // No scrollingViews specified, thus we can't animate anything\r\n            if (isDevMode()) {\r\n                console.warn('No scrollingViews specified, this ng2-page-scroll does not know which DOM elements to scroll');\r\n            }\r\n            return;\r\n        }\r\n\r\n        let startScrollPositionFound = false;\r\n        // Reset start scroll position to 0. If any of the scrollingViews has a different one, it will be extracted next\r\n        pageScrollInstance.startScrollPosition = 0;\r\n\r\n        // Get the start scroll position from the scrollingViews (e.g. if the user already scrolled down the content)\r\n        pageScrollInstance.scrollingViews.forEach((scrollingView: any) => {\r\n            if (Util.isUndefinedOrNull(scrollingView)) {\r\n                return;\r\n            }\r\n            // Get the scrollTop or scrollLeft value of the first scrollingView that returns a value for its \"scrollTop\"\r\n            // or \"scrollLeft\" property that is not undefined and unequal to 0\r\n\r\n            let scrollPosition = pageScrollInstance.getScrollPropertyValue(scrollingView);\r\n            if (!startScrollPositionFound && scrollPosition) {\r\n                // We found a scrollingView that does not have scrollTop or scrollLeft 0\r\n\r\n                // Return the scroll position value, as this will be our startScrollPosition\r\n                pageScrollInstance.startScrollPosition = scrollPosition;\r\n                startScrollPositionFound = true;\r\n            }\r\n        });\r\n\r\n        let pageScrollOffset = pageScrollInstance.getCurrentOffset();\r\n\r\n        // Calculate the target position that the scroll animation should go to\r\n\r\n        let scrollTargetPosition = pageScrollInstance.extractScrollTargetPosition();\r\n        pageScrollInstance.targetScrollPosition = Math.round(\r\n            (pageScrollInstance.verticalScrolling ? scrollTargetPosition.top : scrollTargetPosition.left) - pageScrollOffset);\r\n\r\n        // Calculate the distance we need to go in total\r\n        pageScrollInstance.distanceToScroll = pageScrollInstance.targetScrollPosition - pageScrollInstance.startScrollPosition;\r\n\r\n        if (isNaN(pageScrollInstance.distanceToScroll)) {\r\n            // We weren't able to find the target position, maybe the element does not exist?\r\n\r\n            if (isDevMode()) {\r\n                console.log('Scrolling not possible, as we can\\'t find the specified target');\r\n            }\r\n            pageScrollInstance.fireEvent(false);\r\n            return;\r\n        }\r\n\r\n        // We're at the final destination already\r\n        // OR we need to scroll down but are already at the end\r\n        // OR we need to scroll up but are at the top already\r\n        let allReadyAtDestination = Math.abs(pageScrollInstance.distanceToScroll) < PageScrollConfig._minScrollDistance;\r\n\r\n        // Check how long we need to scroll if a speed option is given\r\n        // Default executionDuration is the specified duration\r\n        pageScrollInstance.executionDuration = pageScrollInstance.duration;\r\n        // Maybe we need to pay attention to the speed option?\r\n        if (!Util.isUndefinedOrNull(pageScrollInstance.speed) && Util.isUndefinedOrNull(pageScrollInstance.duration)) {\r\n            // Speed option is set and no duration => calculate duration based on speed and scroll distance\r\n            pageScrollInstance.executionDuration = pageScrollInstance.distanceToScroll / pageScrollInstance.speed * 1000;\r\n        }\r\n\r\n        // We should go there directly, as our \"animation\" would have one big step\r\n        // only anyway and this way we save the interval stuff\r\n        let tooShortInterval = pageScrollInstance.executionDuration <= PageScrollConfig._interval;\r\n\r\n        if (allReadyAtDestination || tooShortInterval) {\r\n            if (isDevMode()) {\r\n                if (allReadyAtDestination) {\r\n                    console.log('Scrolling not possible, as we can\\'t get any closer to the destination');\r\n                } else {\r\n                    console.log('Scroll duration shorter that interval length, jumping to target');\r\n                }\r\n            }\r\n            pageScrollInstance.setScrollPosition(pageScrollInstance.targetScrollPosition);\r\n            pageScrollInstance.fireEvent(true);\r\n            return;\r\n        }\r\n\r\n        // Register the interrupt listeners if we want an interruptible scroll animation\r\n        if (pageScrollInstance.interruptible ||\r\n            (Util.isUndefinedOrNull(pageScrollInstance.interruptible) && PageScrollConfig.defaultInterruptible)) {\r\n            pageScrollInstance.attachInterruptListeners(this.onInterrupted);\r\n        }\r\n\r\n        // Let's get started, get the start time...\r\n        pageScrollInstance.startTime = new Date().getTime();\r\n        // .. and calculate the end time (when we need to finish at last)\r\n        pageScrollInstance.endTime = pageScrollInstance.startTime + pageScrollInstance.executionDuration;\r\n\r\n        pageScrollInstance.timer = setInterval((_pageScrollInstance: PageScrollInstance) => {\r\n            // Take the current time\r\n            let currentTime: number = new Date().getTime();\r\n\r\n            // Determine the new scroll position\r\n            let newScrollPosition: number;\r\n            let stopNow = false;\r\n            if (_pageScrollInstance.endTime <= currentTime) {\r\n                // We're over the time already, so go the targetScrollPosition (aka destination)\r\n                newScrollPosition = _pageScrollInstance.targetScrollPosition;\r\n                stopNow = true;\r\n            } else {\r\n                // Calculate the scroll position based on the current time using the easing function\r\n                newScrollPosition = Math.round(_pageScrollInstance.easingLogic.ease(\r\n                    currentTime - _pageScrollInstance.startTime,\r\n                    _pageScrollInstance.startScrollPosition,\r\n                    _pageScrollInstance.distanceToScroll,\r\n                    _pageScrollInstance.executionDuration));\r\n            }\r\n            // Set the new scrollPosition to all scrollingViews elements\r\n            if (!_pageScrollInstance.setScrollPosition(newScrollPosition)) {\r\n                // Setting the new scrollTop/scrollLeft value failed for all ScrollingViews\r\n                // early stop the scroll animation to save resources\r\n                stopNow = true;\r\n            }\r\n\r\n            // At the end do the internal stop maintenance and fire the pageScrollFinish event\r\n            // (otherwise the event might arrive at \"too early\")\r\n            if (stopNow) {\r\n                this.stopInternal(false, _pageScrollInstance);\r\n            }\r\n\r\n        }, PageScrollConfig._interval, pageScrollInstance);\r\n\r\n        // Register the instance as running one\r\n        this.runningInstances.push(pageScrollInstance);\r\n    }\r\n\r\n    /**\r\n     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.\r\n     *\r\n     * @param namespace\r\n     * @returns {boolean}\r\n     */\r\n    public stopAll(namespace?: string): boolean {\r\n        if (this.runningInstances.length > 0) {\r\n            let stoppedSome = false;\r\n\r\n            for (let i = 0; i < this.runningInstances.length; ++i) {\r\n                let pageScrollInstance = this.runningInstances[i];\r\n                if (Util.isUndefinedOrNull(namespace) || namespace.length === 0 ||\r\n                    pageScrollInstance.namespace === namespace) {\r\n                    stoppedSome = true;\r\n                    this.stopInternal(true, pageScrollInstance);\r\n                    // Decrease the counter, as we removed an item from the array we iterate over\r\n                    i--;\r\n                }\r\n            }\r\n            return stoppedSome;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public stop(pageScrollInstance: PageScrollInstance): boolean {\r\n        return this.stopInternal(true, pageScrollInstance);\r\n    }\r\n\r\n    constructor() {\r\n        if (PageScrollService.instanceCounter > 0 && isDevMode()) {\r\n            console.warn('An instance of PageScrollService already exists, usually ' +\r\n                'including one provider should be enough, so double check.');\r\n        }\r\n        PageScrollService.instanceCounter++;\r\n    }\r\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\r\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}