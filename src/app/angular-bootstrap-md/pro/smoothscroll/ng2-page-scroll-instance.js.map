{"version":3,"sources":["../../../../src/app/typescripts/pro/smoothscroll/ng2-page-scroll-instance.ts"],"names":[],"mappings":"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","file":"ng2-page-scroll-instance.js","sourceRoot":"","sourcesContent":["/**\r\n * Created by sebastianfuss on 29.08.16.\r\n */\r\n\r\nimport {EventEmitter} from '@angular/core';\r\n\r\nimport {EasingLogic, PageScrollConfig, PageScrollTarget, PageScrollingViews} from './ng2-page-scroll-config';\r\nimport {PageScrollUtilService as Util} from './ng2-page-scroll-util.service';\r\n\r\n/**\r\n * An Interface specifying the possible options to be passed into the newInstance() factory method\r\n */\r\nexport interface PageScrollOptions {\r\n    /**\r\n     * The document object of the current app\r\n     */\r\n    document: Document;\r\n\r\n    /**\r\n     * A specification of the DOM element to scroll to. Either a string referring to an\r\n     * object id (`#target`) or a HTMLElement that is attached to the document's DOM tree.\r\n     */\r\n    scrollTarget: PageScrollTarget;\r\n\r\n    /**\r\n     * Array of HTMLElements or the body object that should be manipulated while performing\r\n     * the scroll animation.\r\n     */\r\n    scrollingViews?: PageScrollingViews[];\r\n\r\n    /**\r\n     * Namespace of the scroll animation\r\n     */\r\n    namespace?: string;\r\n\r\n    /**\r\n     * Whether that scroll animation scrolls in vertical direction (true) or\r\n     * horizontal (false, default value)\r\n     */\r\n    verticalScrolling?: boolean;\r\n\r\n    /**\r\n     * Whether the an advanced offset calculation for inline scrollings should be applied\r\n     */\r\n    advancedInlineOffsetCalculation?: boolean;\r\n\r\n    /**\r\n     * Offset of target elements location and scroll location\r\n     */\r\n    pageScrollOffset?: number;\r\n\r\n    /**\r\n     * Whether the scroll animation should be interruptible\r\n     */\r\n    pageScrollInterruptible?: boolean;\r\n\r\n    /**\r\n     * The easing logic to be used\r\n     */\r\n    pageScrollEasingLogic?: EasingLogic;\r\n\r\n    /**\r\n     * Duration in milliseconds the scroll animation should last\r\n     */\r\n    pageScrollDuration?: number;\r\n\r\n    /**\r\n     * Maximum speed to be used for the scroll animation. Only taken\r\n     * into account of no pageScrollDuration is provided\r\n     */\r\n    pageScrollSpeed?: number;\r\n\r\n    /**\r\n     * A listener to be called whenever the scroll animation stops\r\n     */\r\n    pageScrollFinishListener?: EventEmitter<boolean>;\r\n}\r\n\r\n/**\r\n * Represents a scrolling action\r\n */\r\nexport class PageScrollInstance {\r\n\r\n    /**\r\n     * These properties will be set during instance construction and default to their defaults from PageScrollConfig\r\n     */\r\n\r\n    /* A namespace to \"group\" scroll animations together and stopping some does not stop others */\r\n    private _namespace: string = PageScrollConfig._defaultNamespace;\r\n    /* The document all the scrolling takes place and scroll targets are located in */\r\n    private document: Document;\r\n    /* The DOM elements or similar nodes whose scrollTop/scrollLeft property will be manipulated during scrolling */\r\n    private _scrollingViews: PageScrollingViews[];\r\n    private _isInlineScrolling: boolean;\r\n    /* The target element that should be scrolled into the viewport */\r\n    private _scrollTarget: PageScrollTarget;\r\n\r\n    /* Whether we scroll vertically (true) or horizontally (false) */\r\n    private _verticalScrolling = PageScrollConfig.defaultIsVerticalScrolling;\r\n    /* Offset in px that the animation should stop above that target element */\r\n    private _offset: number = PageScrollConfig.defaultScrollOffset;\r\n    /* Duration in milliseconds the scroll animation should last */\r\n    private _duration: number = PageScrollConfig.defaultDuration;\r\n    /* Speed in \"pixels/second\" to be used when scrolling to the target element */\r\n    private _speed: number;\r\n    /* Easing function to manipulate the scrollTop/scrollLeft value over time */\r\n    private _easingLogic: EasingLogic = PageScrollConfig.defaultEasingLogic;\r\n    /* Boolean whether the scroll animation should stop on user interruption or not */\r\n    private _interruptible: boolean = PageScrollConfig.defaultInterruptible;\r\n    /* The listener that this scroll instance attaches to the body to listen for interrupt events\r\n     We're keeping a reference to it so we can properly remove it when the animation finishes */\r\n    private _interruptListener: EventListenerOrEventListenerObject;\r\n    /* Whether the advanded offset calculation for inline scrolling should be used */\r\n    private _advancedInlineOffsetCalculation: boolean = PageScrollConfig.defaultAdvancedInlineOffsetCalculation;\r\n    /* Event emitter to notify the world about the scrolling */\r\n    private _pageScrollFinish: EventEmitter<boolean> = new EventEmitter<boolean>();\r\n\r\n    /**\r\n     * These properties will be set/manipulated if the scroll animation starts\r\n     */\r\n    /* The initial value of the scrollTop or scrollLeft position when the animation starts */\r\n    private _startScrollPosition = 0;\r\n    /* The target value of the scrollTop or scrollLeft position for the animation (aka \"the final destination\") */\r\n    private _targetScrollPosition: number;\r\n    /* Difference between startScrollPosition and targetScrollPosition. Pre-calculated to minimize computations during animation */\r\n    private _distanceToScroll: number;\r\n    /* The timestamp when the animation starts/got started */\r\n    private _startTime: number;\r\n    /* The estimate end time of the animation, calculated by startTime + duration */\r\n    private _endTime: number;\r\n    /* The duration a started animation takes. This may match the _duration or be adjusted due to the _speed option */\r\n    private _executionDuration: number;\r\n    /* Whether an interrupt listener is attached to the body or not */\r\n    private _interruptListenersAttached = false;\r\n\r\n    /* References to the timer instance that is used to perform the scroll animation to be\r\n     able to clear it on animation end*/\r\n    private _timer: any = null;\r\n\r\n    /*\r\n     * Factory methods for instance creation\r\n     */\r\n    public static simpleInstance(document: Document,\r\n                                 scrollTarget: PageScrollTarget,\r\n                                 namespace?: string): PageScrollInstance {\r\n        return PageScrollInstance.newInstance({\r\n            document,\r\n            scrollTarget,\r\n            namespace\r\n        });\r\n    }\r\n\r\n    public static newInstance(options: PageScrollOptions) {\r\n\r\n        if (Util.isUndefinedOrNull(options.namespace) || options.namespace.length <= 0) {\r\n            options.namespace = PageScrollConfig._defaultNamespace;\r\n        }\r\n        let pageScrollInstance: PageScrollInstance = new PageScrollInstance(options.namespace, document);\r\n\r\n        if (Util.isUndefinedOrNull(options.scrollingViews) || options.scrollingViews.length === 0) {\r\n            pageScrollInstance._isInlineScrolling = false;\r\n            pageScrollInstance._scrollingViews = [document.documentElement, document.body, document.body.parentNode];\r\n        } else {\r\n            pageScrollInstance._isInlineScrolling = true;\r\n            pageScrollInstance._scrollingViews = options.scrollingViews;\r\n        }\r\n\r\n        pageScrollInstance._scrollTarget = options.scrollTarget;\r\n\r\n        if (!Util.isUndefinedOrNull(options.verticalScrolling)) {\r\n            pageScrollInstance._verticalScrolling = options.verticalScrolling;\r\n        }\r\n\r\n        if (!Util.isUndefinedOrNull(options.pageScrollOffset)) {\r\n            pageScrollInstance._offset = options.pageScrollOffset;\r\n        }\r\n\r\n        if (!Util.isUndefinedOrNull(options.pageScrollEasingLogic)) {\r\n            pageScrollInstance._easingLogic = options.pageScrollEasingLogic;\r\n        }\r\n\r\n        if (Util.isUndefinedOrNull(options.pageScrollDuration) && !Util.isUndefinedOrNull(options.pageScrollSpeed)) {\r\n            // No duration specified in the options, only in this case we use the speed option when present\r\n            pageScrollInstance._speed = options.pageScrollSpeed;\r\n            pageScrollInstance._duration = undefined;\r\n        } else if (!Util.isUndefinedOrNull(options.pageScrollDuration)) {\r\n            pageScrollInstance._duration = options.pageScrollDuration;\r\n        }\r\n\r\n        if (!Util.isUndefinedOrNull(options.pageScrollFinishListener)) {\r\n            pageScrollInstance._pageScrollFinish = options.pageScrollFinishListener;\r\n        }\r\n\r\n        pageScrollInstance._interruptible = options.pageScrollInterruptible ||\r\n            (Util.isUndefinedOrNull(options.pageScrollInterruptible) && PageScrollConfig.defaultInterruptible);\r\n\r\n        pageScrollInstance._advancedInlineOffsetCalculation = options.advancedInlineOffsetCalculation ||\r\n            (Util.isUndefinedOrNull(options.advancedInlineOffsetCalculation) &&\r\n            PageScrollConfig.defaultAdvancedInlineOffsetCalculation);\r\n\r\n        return pageScrollInstance;\r\n    }\r\n\r\n    /**\r\n     * Create a PageScrollInstance representing a scroll animation on the documents body.\r\n     *\r\n     * @param document The document that contains the body to be scrolled and the scrollTarget elements\r\n     * @param scrollTarget Where to scroll to. Can be a HTMLElement reference or a string like '#elementId'\r\n     * @param verticalScrolling\r\n     * @param namespace Optional namespace to group scroll animations logically\r\n     * @returns {PageScrollInstance}\r\n     *\r\n     * @deprecated Use {@link newInstance(options: PageScrollOptions)}\r\n     **/\r\n    public static simpleDirectionInstance(document: Document,\r\n                                          scrollTarget: PageScrollTarget,\r\n                                          verticalScrolling: boolean,\r\n                                          namespace?: string): PageScrollInstance {\r\n        return PageScrollInstance.newInstance({\r\n            document,\r\n            scrollTarget,\r\n            namespace,\r\n            verticalScrolling,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a PageScrollInstance representing a scroll animation to the target element where the scrollingView\r\n     * elements get scrolled (like a div container with fixed height, resulting in scrollbars in it).\r\n     *\r\n     * Make sure that the scrollTarget is located inside the scrollingView in the DOM hierarchy, otherwise the\r\n     * scrollingView will be scrolled to an apparently arbitrary position.\r\n     *\r\n     * @param document The document that contains the body to be scrolled and the scrollTarget elements\r\n     * @param scrollTarget Where to scroll to. Can be a HTMLElement reference or a string like '#elementId'\r\n     * @param scrollingView The element that should be scrolled\r\n     * @param namespace Optional namespace to group scroll animations logically\r\n     * @returns {PageScrollInstance}\r\n     *\r\n     * @deprecated Use {@link newInstance(options: PageScrollOptions)}\r\n     */\r\n    public static simpleInlineInstance(document: Document,\r\n                                       scrollTarget: PageScrollTarget,\r\n                                       scrollingView: PageScrollingViews,\r\n                                       namespace?: string): PageScrollInstance {\r\n        return PageScrollInstance.newInstance({\r\n            document,\r\n            scrollTarget,\r\n            scrollingViews: [scrollingView],\r\n            verticalScrolling: true,\r\n            namespace\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param document The document that contains the body to be scrolled and the scrollTarget elements\r\n     * @param scrollTarget Where to scroll to. Can be a HTMLElement reference or a string like '#elementId'\r\n     * @param scrollingView The element that should be scrolled\r\n     * @param verticalScrolling whether the scrolling should be performed in vertical direction (true, default) or horizontal (false)\r\n     * @param namespace Optional namespace to group scroll animations logically\r\n     * @returns {PageScrollInstance}\r\n     *\r\n     * @deprecated Use {@link newInstance(options: PageScrollOptions)}\r\n     */\r\n    public static simpleInlineDirectionInstance(document: Document,\r\n                                                scrollTarget: PageScrollTarget,\r\n                                                scrollingView: PageScrollingViews,\r\n                                                verticalScrolling: boolean,\r\n                                                namespace?: string): PageScrollInstance {\r\n        return PageScrollInstance.newInstance({\r\n            document,\r\n            scrollTarget,\r\n            scrollingViews: [scrollingView],\r\n            namespace,\r\n            verticalScrolling,\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param document The document that contains the body to be scrolled and the scrollTarget elements\r\n     * @param scrollTarget Where to scroll to. Can be a HTMLElement reference or a string like '#elementId'\r\n     * @param scrollingViews The elements that should be scrolled. Null to use the default elements of document and body.\r\n     * @param namespace Optional namespace to group scroll animations logically\r\n     * @param verticalScrolling whether the scrolling should be performed in vertical direction (true, default) or horizontal (false)\r\n     * @param pageScrollOffset The offset to be attached to the top of the target element or\r\n     *                          null/undefined to use application default\r\n     * @param pageScrollInterruptible Whether this scroll animation should be interruptible.\r\n     *                                 Null/undefined for application default\r\n     * @param pageScrollEasingLogic Easing function to be used for manipulating the scroll position\r\n     *                          over time. Null/undefined for application default\r\n     * @param pageScrollDuration The duration in milliseconds the animation should last.\r\n     *                            Null/undefined for application default\r\n     * @param pageScrollFinishListener Listener to be called to notify other parts of the application\r\n     *                                  that the scroll animation has finished\r\n     * @returns {PageScrollInstance}\r\n     *\r\n     * @deprecated Use {@link newInstance(options: PageScrollOptions)}\r\n     */\r\n    public static advancedInstance(document: Document,\r\n                                   scrollTarget: PageScrollTarget,\r\n                                   scrollingViews?: PageScrollingViews[],\r\n                                   namespace?: string,\r\n                                   verticalScrolling?: boolean,\r\n                                   pageScrollOffset?: number,\r\n                                   pageScrollInterruptible?: boolean,\r\n                                   pageScrollEasingLogic?: EasingLogic,\r\n                                   pageScrollDuration?: number,\r\n                                   pageScrollFinishListener?: EventEmitter<boolean>): PageScrollInstance {\r\n        return PageScrollInstance.newInstance({\r\n            document,\r\n            scrollTarget,\r\n            scrollingViews,\r\n            namespace,\r\n            verticalScrolling,\r\n            pageScrollOffset,\r\n            pageScrollInterruptible,\r\n            pageScrollEasingLogic,\r\n            pageScrollDuration,\r\n            pageScrollFinishListener\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Private constructor, requires the properties assumed to be the bare minimum.\r\n     * Use the factory methods to create instances:\r\n     *      {@link PageScrollInstance#simpleInstance}\r\n     *      {@link PageScrollInstance#newInstance}\r\n     * @param namespace\r\n     * @param document\r\n     */\r\n    constructor(namespace: string, document: Document) {\r\n        this._namespace = namespace;\r\n        this.document = document;\r\n    }\r\n\r\n    public getScrollPropertyValue(scrollingView: any): number {\r\n        if (!this.verticalScrolling) {\r\n            return scrollingView.scrollLeft;\r\n        }\r\n        return scrollingView.scrollTop;\r\n    }\r\n\r\n    /**\r\n     * Extract the exact location of the scrollTarget element.\r\n     *\r\n     * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be\r\n     * a string like \"#heading2\", then this method returns the corresponding DOM element for that id.\r\n     *\r\n     * @returns {HTMLElement}\r\n     */\r\n    public extractScrollTargetPosition(): {top: number, left: number} {\r\n        let scrollTargetElement: HTMLElement;\r\n        if (typeof this._scrollTarget === 'string') {\r\n            scrollTargetElement = this.document.getElementById((<string>this._scrollTarget).substr(1));\r\n        } else {\r\n            scrollTargetElement = <HTMLElement>this._scrollTarget;\r\n        }\r\n\r\n        if (scrollTargetElement === null || scrollTargetElement === undefined) {\r\n            // Scroll target not found\r\n            return {top: NaN, left: NaN};\r\n        }\r\n\r\n        if (this._isInlineScrolling) {\r\n            let position = {top: scrollTargetElement.offsetTop, left: scrollTargetElement.offsetLeft};\r\n            if (this._advancedInlineOffsetCalculation && this.scrollingViews.length === 1) {\r\n                let accumulatedParentsPos = {top: 0, left: 0};\r\n                // not named window to make sure we're not getting the global window variable by accident\r\n                let theWindow = scrollTargetElement.ownerDocument.defaultView;\r\n                let parentFound = false;\r\n\r\n                // Start parent is the immediate parent\r\n                let parent = scrollTargetElement.parentElement;\r\n\r\n                // Iterate upwards all parents\r\n                while (!parentFound && !Util.isUndefinedOrNull(parent)) {\r\n                    if (theWindow.getComputedStyle(parent).getPropertyValue('position') === 'relative') {\r\n                        accumulatedParentsPos.top += parent.offsetTop;\r\n                        accumulatedParentsPos.left += parent.offsetLeft;\r\n                    }\r\n                    // Next iteration\r\n                    parent = parent.parentElement;\r\n                    parentFound = parent === this.scrollingViews[0];\r\n                }\r\n                if (parentFound) {\r\n                    // Only use the results if we found the parent, otherwise we accumulated too much anyway\r\n                    position.top += accumulatedParentsPos.top;\r\n                    position.left += accumulatedParentsPos.left;\r\n                } else {\r\n                    if (PageScrollConfig._logLevel >= 2) {\r\n                        console.warn('Unable to find nested scrolling targets parent!');\r\n                    }\r\n                }\r\n            }\r\n            return position;\r\n        }\r\n\r\n        return Util.extractElementPosition(this.document, scrollTargetElement);\r\n    }\r\n\r\n    /**\r\n     * Get the top offset of the scroll animation.\r\n     * This automatically takes the offset location of the scrolling container/scrolling view\r\n     * into account (for nested/inline scrolling).\r\n     *\r\n     * @returns {number}\r\n     */\r\n    public getCurrentOffset(): number {\r\n        return this._offset;\r\n    }\r\n\r\n    /**\r\n     * Sets the \"scrollTop\" or \"scrollLeft\" property for all scrollingViews to the provided value\r\n     * @param position\r\n     * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.\r\n     *          false if it failed for all ScrollingViews, meaning that we should stop the animation\r\n     *          (probably because we're at the end of the scrolling region)\r\n     */\r\n    public setScrollPosition(position: number): boolean {\r\n        if (PageScrollConfig._logLevel >= 5) {\r\n            console.warn('Scroll Position: ' + position);\r\n        }\r\n        // Set the new scrollTop/scrollLeft to all scrollingViews elements\r\n        return this.scrollingViews.reduce((oneAlreadyWorked: any, scrollingView: any) => {\r\n            let startScrollPropertyValue = this.getScrollPropertyValue(scrollingView);\r\n            if (scrollingView && !Util.isUndefinedOrNull(startScrollPropertyValue)) {\r\n                let scrollDistance = Math.abs(startScrollPropertyValue - position);\r\n\r\n                // The movement we need to perform is less than 2px\r\n                // This we consider a small movement which some browser may not perform when\r\n                // changing the scrollTop/scrollLeft property\r\n                // Thus in this cases we do not stop the scroll animation, although setting the\r\n                // scrollTop/scrollLeft value \"fails\"\r\n                let isSmallMovement = scrollDistance < PageScrollConfig._minScrollDistance;\r\n\r\n                if (!this.verticalScrolling) {\r\n                    scrollingView.scrollLeft = position;\r\n                } else {\r\n                    scrollingView.scrollTop = position;\r\n                }\r\n\r\n                // Return true of setting the new scrollTop/scrollLeft value worked\r\n                // We consider that it worked if the new scrollTop/scrollLeft value is closer to the\r\n                // desired scrollTop/scrollLeft than before (it might not be exactly the value we\r\n                // set due to dpi or rounding irregularities)\r\n                if (isSmallMovement || scrollDistance > Math.abs(this.getScrollPropertyValue(scrollingView) - position)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return oneAlreadyWorked;\r\n        }, false);\r\n    }\r\n\r\n    /**\r\n     * Trigger firing a animation finish event\r\n     * @param value Whether the animation finished at the target (true) or got interrupted (false)\r\n     */\r\n    public fireEvent(value: boolean): void {\r\n        if (this._pageScrollFinish) {\r\n            this._pageScrollFinish.emit(value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter\r\n     * will be called if any of the attached events is fired.\r\n     *\r\n     * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.\r\n     *\r\n     * @param interruptReporter\r\n     */\r\n    public attachInterruptListeners(interruptReporter: InterruptReporter): void {\r\n        if (this._interruptListenersAttached) {\r\n            // Detach possibly existing listeners first\r\n            this.detachInterruptListeners();\r\n        }\r\n        this._interruptListener = (event: Event): void => {\r\n            interruptReporter.report(event, this);\r\n        };\r\n        PageScrollConfig._interruptEvents.forEach(\r\n            (event: string) => this.document.body.addEventListener(event, this._interruptListener)\r\n        );\r\n        this._interruptListenersAttached = true;\r\n    }\r\n\r\n    /**\r\n     * Remove event listeners from the body and stop listening for events that might be treated as \"animation\r\n     * interrupt\" events.\r\n     */\r\n    public detachInterruptListeners(): void {\r\n        PageScrollConfig._interruptEvents.forEach(\r\n            (event: string) => this.document.body.removeEventListener(event, this._interruptListener)\r\n        );\r\n        this._interruptListenersAttached = false;\r\n    }\r\n\r\n    public get namespace(): string {\r\n        return this._namespace;\r\n    }\r\n\r\n    get scrollTarget(): PageScrollTarget {\r\n        return this._scrollTarget;\r\n    }\r\n\r\n    get verticalScrolling(): boolean {\r\n        return this._verticalScrolling;\r\n    }\r\n\r\n    public get scrollingViews(): any[] {\r\n        return this._scrollingViews;\r\n    }\r\n\r\n    public set startScrollPosition(value: number) {\r\n        this._startScrollPosition = value;\r\n    }\r\n\r\n    public get startScrollPosition(): number {\r\n        return this._startScrollPosition;\r\n    }\r\n\r\n    public set targetScrollPosition(value: number) {\r\n        this._targetScrollPosition = value;\r\n    }\r\n\r\n    public get targetScrollPosition(): number {\r\n        return this._targetScrollPosition;\r\n    }\r\n\r\n    public set distanceToScroll(value: number) {\r\n        this._distanceToScroll = value;\r\n    }\r\n\r\n    public get distanceToScroll(): number {\r\n        return this._distanceToScroll;\r\n    }\r\n\r\n    get executionDuration(): number {\r\n        return this._executionDuration;\r\n    }\r\n\r\n    set executionDuration(value: number) {\r\n        this._executionDuration = value;\r\n    }\r\n\r\n    public get duration(): number {\r\n        return this._duration;\r\n    }\r\n\r\n    public get speed(): number {\r\n        return this._speed;\r\n    }\r\n\r\n    public get easingLogic(): EasingLogic {\r\n        return this._easingLogic;\r\n    }\r\n\r\n    public get interruptible(): boolean {\r\n        return this._interruptible;\r\n    }\r\n\r\n    public set startTime(value: number) {\r\n        this._startTime = value;\r\n    }\r\n\r\n    public get startTime(): number {\r\n        return this._startTime;\r\n    }\r\n\r\n    public set endTime(value: number) {\r\n        this._endTime = value;\r\n    }\r\n\r\n    public get endTime(): number {\r\n        return this._endTime;\r\n    }\r\n\r\n    public set timer(value: any) {\r\n        this._timer = value;\r\n    }\r\n\r\n    public get timer(): any {\r\n        return this._timer;\r\n    }\r\n\r\n    public get interruptListenersAttached(): boolean {\r\n        return this._interruptListenersAttached;\r\n    }\r\n}\r\n\r\n/**\r\n * An Interface a listener should implement to be notified about possible interrupt events\r\n * that happened due to user interaction while a scroll animation takes place.\r\n *\r\n * The PageScrollService provides an implementation to a PageScrollInstance to be notified\r\n * about scroll animation interrupts and stop related animations.\r\n */\r\nexport interface InterruptReporter {\r\n    report: {\r\n        (event: Event, pageScrollInstance: PageScrollInstance): void;\r\n    };\r\n}"]}